# 20243097양태웅 과제
1.`리룩스 명령어 top`
***
```
top 명령어는 Linux 및 유닉스 계열 운영 체제에서 실시간으로
시스템의 프로세스와 리소스 사용 상태를 모니터링 하는 도구 입니다.

이명령어를 실행하면,CPU,메모리사용랑,실행 중인 프로세스 목록 및
각 프로세스에 대한 다양한 정보를 제공하는 대화영 텍스트 기반 인터페이스가 표시된다
```
***
1.1`주요기능`

**프로세스 정보**
+ 프로세스ID(PID),사용자(USER),우선순위(PR),니쓰값(NI),가상 메모리 사용량(VIRT),
실제 메모리 사용량(RES),공유 메모리(SHR),상태(S),CPU 사용률(%CPU),메모리 사용률(%MEM)
등을 보여줍니다.

**시스템 정보**
+ 시스템의 가동시간, 로그인한 사용자 수, 평균 부하(로드 애버리지), 작업 중인 프로세스의 수,
총 프로세스 수 등의 정보를 제공합니다.

**대화형 컨트롤**
+ 사용자는 top 실행 중에 키보드 명령어를 사용하여 출력을 정렬하거나 특정 프로세스를
찾아볼수 있습니다.
***
2.`리눅스 명령어 jobs`
***
```
jobs 명령어는 작업의 상태를 표시하는 명령어다. 현재 쉘 세션에서 실행기킨
백그라운드 작업의 목록이 출력되며, 각 작업에는 번호가 붙어 있어 kill명령어 뒤에 '%번호'
등으로 사용할수 있다.
간단히 말하면 jobs명령어는 현제 쉴 프로세스의 자식 백르라운드 프로세스들을 보여준다고 생각하면 된다.
```
`jobs 로 출력되는 백그라운드 작업의 상태값은 다음과 같다.`
|상태||설명|
|----------|-----|-----------|
|Running|N/A|작업이 계속 진행중임|
|Done|N/A|작업이 완료되어 0을 반환|
|Done(code)|N/A|작업이 종료되었우며 0 이 아닌 코드를 반환|
|Stopped|N/A|작업이 일시 중단|
|Stopped(SIGTSTP)|N/A|SIGTSTP 시그널이 작업을 일시 중단|
|Stopped(SIGSTOP)|N/A|SIGSTOP 시그널이 작업을 일시 중단|
|Stopped(SIGTTTIN)|N/A|SIGTTTIN 시그널이 작업을 일시 중단|
|Stopped(SIGTTOU|N/A|SIGTTOU 시그널이 작업을 일시 중단|


`옵션`


|옵션||설명|
|------|-----|----|
|-ㅣ|N/A|프로세스 ID를 state 필드 앞에 출력|
|-n|N/A|프로세스 그룹 중에 대표 프로세스 ID를 출력|
|-p|N/A|각 프로세스 ID에 대해 한 행씩 출력|
|command|N/A|지정한 명령어를 실행|


3.`리녹스 명령어 ps`
```
ps 명령어는 Process State의 약자로 현재 실행 중인 프로세스와 상태를 출력하는 명령어입니다.
man ps를 사용 시 ps 명령어와 관련된 매뉴얼을 볼 수 있는데, ps 명령어의 옵션은 
각 시스템 계열 System V(-), BSD(- 사용 안 함), GNU(--)마다 다른 표기법 및 출력을 가지고 있습니다.

그래서 만약 제가 포스트한 명령어 옵션이 의도대로 사용이 안 된다면 꼭 man ps를 통해서 옵션 표기 및 설명을 확인해야 한다. 

보통 grep 명령어와 많이 사용됩니다.
```
3.1`ps 명령어`
|ps||사용자와 관련된 프로세스만 출력합니다.|
|------|-|----|

3.2`ps 명령어 출력 항목`

|USER (BSD),UID (System V)||프로세스 소유자의 이름|
|------|-----|----|
|PID||프로세스의 식별 번호|
|PPID||부모 프로세스의 PID|
|%CPU||CPU 사용 비율의 추정치 (BSD)|
|%MEM||Memory 사용 비율의 추정치(BSD)|
|VSZ||K 단위 또는 페이지 단위의 가상 메모리 사용량|
|RSS||실제 메모리 사용량|
|TTY||프로세스와 연결된 터미널|
|S (System V), STAT (BSD)||지한 명령어를 실행현재 프로세스의 상태 코드|
|TIME||총 CPU 사용 시간|
|COMMAND||프로세스의 실행 명령행|
|STIME||프로세스가 시작된 시간 혹은 날짜|
|C (System V), CP (BSD)||짧은 기간 동안의 CPU 사용률|
|F||플래그|
|PRI||실제 실행 우선순위|
|NI||nice 우선순위 번호|

3.3`ps 명령어 옵션`

|-A||모든 프로세스를 출력|
|------------------|-----|------------------------|
|a (BSD)||터미널과 연관된 프로세스를 출력, x 옵션과 같이 사용하여 모든 프로세스를 출력할 때 사용|
|-a||세션 리더를 제외하고 데몬 프로세스처럼 터미널에 종속되지 않은 모든 프로세스를 출력|
|-e||커널 프로세스를 제외한 모든 프로세스를 출력|
|-f||출력을 풀 포맷으로 표기 (유닉스 스타일) UID, PID , PPID 등이 함께 표시|
|-l (System V),l (BSD)||출력을 긴 포맷으로 표기 프로세스의 정보를 길게 보여주는 옵션으로 우선순위와 관련된 PRI 값과 NI 값을 확인|
|-o||출력 포맷을 지정|
|-M||64비트 프로세스들을 출력|
|-m||프로세스뿐만 아니라 커널 스레드도 출력|
|-p||특정 PID를 지정하여 출력|
|-r||현재 실행 중인 프로세스 출력|
|u (BSD)||프로세스의 소유자를 기준으로 출력|
|-u [사용자]||특정 사용자의 프로세스 정보를 출력, 사용자를 지정하지 않는다면 현재 사용자 기준으로 출력|
|x (BSD)||데몬 프로세스처럼 터미널에 종속되지 않은 프로세스를 출력|
|-x||로그인 상태에 있는 동안 아직 완료되지 않은 프로세스를 출력.*유닉스 시스템은 사용자가 로그아웃한 뒤에도 임의의 프로세서가 계속 동작 가능 -> 해당 프로세서는 자신이 실행시킨 쉘이 없어도 계속 자신의 일을 수행하는 데 이 프로세스는 해당 옵션 없이는 확인이 불가능|
4.`리눅스 명령어 kill`
```
kill 명령어는 대개 프로세스를 죽일 때 사용합니다. 하지만 내부적으로는 프로세스에 시그널을 보내 원하는 작업을 하게 하는 명령어입니다
```
+ **프로세스 죽이는 방법**
죽이려는 프로세스의 pid를 얻은 다음 kill 명령어의 인자로 넘기면 됩니다.
예를들어 node.js로 실행 중인 서버를 죽이고 싶다면 ps 명령어를 통해 node.js의 pid를 얻고 kill 명령어의 파라미터로 넘겨 실행시키면 종료시킬 수 있다.
![image](https://github.com/didcombo/test1/assets/170289977/0fc94509-527b-4273-b6b1-b7781426cbae)

+ **사용자 지정 시그널 전송 방법**
kill 명령어의 default 시그널은 TERM(15) 입니다. 하지만 -s 명령으로 다른 시그널을 보낼 수 있다.
